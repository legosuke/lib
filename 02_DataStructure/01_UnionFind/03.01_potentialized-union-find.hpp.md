---
data:
  _extendedDependsOn: []
  _extendedRequiredBy: []
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/02_DataStructure/01_UnionFind/03.01_AOJ-DSL-1-B.test.cpp
    title: test/02_DataStructure/01_UnionFind/03.01_AOJ-DSL-1-B.test.cpp
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    document_title: "\u30DD\u30C6\u30F3\u30B7\u30E3\u30EB\u4ED8\u304D Union-Find"
    links: []
  bundledCode: "#line 2 \"02_DataStructure/01_UnionFind/03.01_potentialized-union-find.hpp\"\
    \n#include <cassert>\n#include <cstdlib>\n#include <utility>\n#include <vector>\n\
    \n/**\n * @brief \u30DD\u30C6\u30F3\u30B7\u30E3\u30EB\u4ED8\u304D Union-Find\n\
    \ */\ntemplate <typename T>\nclass PotentializedUnionFind {\npublic:\n    PotentializedUnionFind()\
    \ = default;\n    explicit PotentializedUnionFind(std::uint32_t n)\n        :\
    \ _n(n), _num(n), _par(n, n), _size(n, 1), _weight(n) {}\n\n    bool unite_trees(std::uint32_t\
    \ x, std::uint32_t y, T w) {\n        assert(0 <= x && x < _n && 0 <= y && y <\
    \ _n);\n        w += weight(x); w -= weight(y);\n        x = find_root(x); y =\
    \ find_root(y);\n        if (x == y) return (w == 0);\n        if (_size[x] <\
    \ _size[y]) std::swap(x, y), w = -w;\n        _size[x] += _size[y];\n        _par[y]\
    \ = x;\n        _weight[y] = w;\n        --_num;\n        return true;\n    }\n\
    \    std::uint32_t find_root(std::uint32_t x) {\n        assert(0 <= x && x <\
    \ _n);\n        if (_par[x] == _n) return x;\n        std::uint32_t root = find_root(_par[x]);\n\
    \        _weight[x] += _weight[_par[x]];\n        return _par[x] = root;\n   \
    \ }\n    bool is_root(std::uint32_t x) {\n        assert(0 <= x && x < _n);\n\
    \        return (_par[x] == _n);\n    }\n    bool is_same(std::uint32_t x, std::uint32_t\
    \ y) {\n        assert(0 <= x && x < _n && 0 <= y && y < _n);\n        return\
    \ (find_root(x) == find_root(y));\n    }\n    std::size_t tree_size(std::uint32_t\
    \ x) {\n        assert(0 <= x && x < _n);\n        return _size[find_root(x)];\n\
    \    }\n    std::size_t number_of_trees() {\n        return _num;\n    }\n   \
    \ T weight(std::uint32_t x) {\n        assert(0 <= x && x < _n);\n        find_root(x);\n\
    \        return _weight[x];\n    }\n    T diff_weight(std::uint32_t x, std::uint32_t\
    \ y) {\n        assert(0 <= x && x < _n && 0 <= y && y < _n);\n        assert(is_same(x,\
    \ y));\n        return weight(y) - weight(x);\n    }\n\nprotected:\n    std::uint32_t\
    \ _n, _num;\n    std::vector<std::uint32_t> _par, _size;\n    std::vector<T> _weight;\n\
    };\n"
  code: "#pragma once\n#include <cassert>\n#include <cstdlib>\n#include <utility>\n\
    #include <vector>\n\n/**\n * @brief \u30DD\u30C6\u30F3\u30B7\u30E3\u30EB\u4ED8\
    \u304D Union-Find\n */\ntemplate <typename T>\nclass PotentializedUnionFind {\n\
    public:\n    PotentializedUnionFind() = default;\n    explicit PotentializedUnionFind(std::uint32_t\
    \ n)\n        : _n(n), _num(n), _par(n, n), _size(n, 1), _weight(n) {}\n\n   \
    \ bool unite_trees(std::uint32_t x, std::uint32_t y, T w) {\n        assert(0\
    \ <= x && x < _n && 0 <= y && y < _n);\n        w += weight(x); w -= weight(y);\n\
    \        x = find_root(x); y = find_root(y);\n        if (x == y) return (w ==\
    \ 0);\n        if (_size[x] < _size[y]) std::swap(x, y), w = -w;\n        _size[x]\
    \ += _size[y];\n        _par[y] = x;\n        _weight[y] = w;\n        --_num;\n\
    \        return true;\n    }\n    std::uint32_t find_root(std::uint32_t x) {\n\
    \        assert(0 <= x && x < _n);\n        if (_par[x] == _n) return x;\n   \
    \     std::uint32_t root = find_root(_par[x]);\n        _weight[x] += _weight[_par[x]];\n\
    \        return _par[x] = root;\n    }\n    bool is_root(std::uint32_t x) {\n\
    \        assert(0 <= x && x < _n);\n        return (_par[x] == _n);\n    }\n \
    \   bool is_same(std::uint32_t x, std::uint32_t y) {\n        assert(0 <= x &&\
    \ x < _n && 0 <= y && y < _n);\n        return (find_root(x) == find_root(y));\n\
    \    }\n    std::size_t tree_size(std::uint32_t x) {\n        assert(0 <= x &&\
    \ x < _n);\n        return _size[find_root(x)];\n    }\n    std::size_t number_of_trees()\
    \ {\n        return _num;\n    }\n    T weight(std::uint32_t x) {\n        assert(0\
    \ <= x && x < _n);\n        find_root(x);\n        return _weight[x];\n    }\n\
    \    T diff_weight(std::uint32_t x, std::uint32_t y) {\n        assert(0 <= x\
    \ && x < _n && 0 <= y && y < _n);\n        assert(is_same(x, y));\n        return\
    \ weight(y) - weight(x);\n    }\n\nprotected:\n    std::uint32_t _n, _num;\n \
    \   std::vector<std::uint32_t> _par, _size;\n    std::vector<T> _weight;\n};"
  dependsOn: []
  isVerificationFile: false
  path: 02_DataStructure/01_UnionFind/03.01_potentialized-union-find.hpp
  requiredBy: []
  timestamp: '2021-01-09 20:59:12+00:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/02_DataStructure/01_UnionFind/03.01_AOJ-DSL-1-B.test.cpp
documentation_of: 02_DataStructure/01_UnionFind/03.01_potentialized-union-find.hpp
layout: document
redirect_from:
- /library/02_DataStructure/01_UnionFind/03.01_potentialized-union-find.hpp
- /library/02_DataStructure/01_UnionFind/03.01_potentialized-union-find.hpp.html
title: "\u30DD\u30C6\u30F3\u30B7\u30E3\u30EB\u4ED8\u304D Union-Find"
---
