---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: template/graph.hpp
    title: template/graph.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/03_Graph/02_GraphAlgorithm/01.01.03.01_AOJ-GRL-1-A.test.cpp
    title: test/03_Graph/02_GraphAlgorithm/01.01.03.01_AOJ-GRL-1-A.test.cpp
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 2 \"03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp\"\
    \n#include <cassert>\n#include <limits>\n#include <queue>\n#include <type_traits>\n\
    #line 2 \"template/graph.hpp\"\n#include <cstdint>\n#include <vector>\n\ntemplate\
    \ <typename T = std::uint32_t>\nstruct Edge {\n    std::uint32_t from, to;\n \
    \   T weight;\n    Edge(std::uint32_t f, std::uint32_t t, T w) : from(f), to(t),\
    \ weight(w) {}\n    using weight_type = T;\n};\n\nstruct UnweightedEdge : Edge<>\
    \ {\n    explicit UnweightedEdge(std::uint32_t t) : Edge<>(-1, t, 1) {}\n    explicit\
    \ UnweightedEdge(std::uint32_t f, std::uint32_t t) : Edge<>(f, t, 1) {}\n};\n\
    using UnweightedEdges = std::vector<UnweightedEdge>;\nusing UnweightedGraph =\
    \ std::vector<UnweightedEdges>;\n\ntemplate <typename T = std::uint32_t>\nstruct\
    \ WeightedEdge : Edge<T> {\n    explicit WeightedEdge(std::uint32_t t, T w) :\
    \ Edge<T>(-1, t, w) {}\n    explicit WeightedEdge(std::uint32_t f, std::uint32_t\
    \ t, T w) : Edge<T>(f, t, w) {}\n};\ntemplate <typename T = std::uint32_t> using\
    \ WeightedEdges = std::vector<WeightedEdge<T>>;\ntemplate <typename T = std::uint32_t>\
    \ using WeightedGraph = std::vector<WeightedEdges<T>>;\n#line 7 \"03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp\"\
    \n\ntemplate <typename T>\nclass Dijkstra {\npublic:\n    Dijkstra(std::uint32_t\
    \ n) : g(n) {}\n\n    void add_edge(std::uint32_t a, std::uint32_t b, T w) {\n\
    \        g[a].emplace_back(b, w);\n    }\n\n    void build(std::uint32_t s) {\n\
    \        using P = std::pair<T, std::uint32_t>;\n        std::priority_queue<P,\
    \ std::vector<P>, std::greater<P>> que;\n        dist.assign(g.size(), INF);\n\
    \        prev.assign(g.size(), -1);\n        que.emplace(0, s);\n        dist[s]\
    \ = 0;\n        while (!que.empty()) {\n            auto p = que.top(); que.pop();\n\
    \            if (dist[p.second] < p.first) continue;\n            for (auto&&\
    \ e : g[p.second]) if (dist[e.to] > dist[p.second] + e.weight) {\n           \
    \     dist[e.to] = dist[p.second] + e.weight;\n                prev[e.to] = p.second;\n\
    \                que.emplace(dist[e.to], e.to);\n            }\n        }\n  \
    \  }\n\n    bool reach(std::uint32_t t) {\n        return dist[t] < INF;\n   \
    \ }\n\n    T distance(std::uint32_t t) {\n        return dist[t];\n    }\n\n \
    \   std::vector<std::uint32_t> path(std::uint32_t t) {\n        std::vector<std::uint32_t>\
    \ res(t);\n        while (prev[res.back()] != -1) {\n            res.push_back(prev[res.back()]);\n\
    \        }\n        std::reverse(begin(res), end(res));\n        return res;\n\
    \    }\n\nprivate:\n    const T INF = std::numeric_limits<T>::max();\n    WeightedGraph<T>\
    \ g;\n    std::vector<T> dist;\n    std::vector<std::uint32_t> prev;\n};\n"
  code: "#pragma once\n#include <cassert>\n#include <limits>\n#include <queue>\n#include\
    \ <type_traits>\n#include \"../../template/graph.hpp\"\n\ntemplate <typename T>\n\
    class Dijkstra {\npublic:\n    Dijkstra(std::uint32_t n) : g(n) {}\n\n    void\
    \ add_edge(std::uint32_t a, std::uint32_t b, T w) {\n        g[a].emplace_back(b,\
    \ w);\n    }\n\n    void build(std::uint32_t s) {\n        using P = std::pair<T,\
    \ std::uint32_t>;\n        std::priority_queue<P, std::vector<P>, std::greater<P>>\
    \ que;\n        dist.assign(g.size(), INF);\n        prev.assign(g.size(), -1);\n\
    \        que.emplace(0, s);\n        dist[s] = 0;\n        while (!que.empty())\
    \ {\n            auto p = que.top(); que.pop();\n            if (dist[p.second]\
    \ < p.first) continue;\n            for (auto&& e : g[p.second]) if (dist[e.to]\
    \ > dist[p.second] + e.weight) {\n                dist[e.to] = dist[p.second]\
    \ + e.weight;\n                prev[e.to] = p.second;\n                que.emplace(dist[e.to],\
    \ e.to);\n            }\n        }\n    }\n\n    bool reach(std::uint32_t t) {\n\
    \        return dist[t] < INF;\n    }\n\n    T distance(std::uint32_t t) {\n \
    \       return dist[t];\n    }\n\n    std::vector<std::uint32_t> path(std::uint32_t\
    \ t) {\n        std::vector<std::uint32_t> res(t);\n        while (prev[res.back()]\
    \ != -1) {\n            res.push_back(prev[res.back()]);\n        }\n        std::reverse(begin(res),\
    \ end(res));\n        return res;\n    }\n\nprivate:\n    const T INF = std::numeric_limits<T>::max();\n\
    \    WeightedGraph<T> g;\n    std::vector<T> dist;\n    std::vector<std::uint32_t>\
    \ prev;\n};"
  dependsOn:
  - template/graph.hpp
  isVerificationFile: false
  path: 03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp
  requiredBy: []
  timestamp: '2021-04-26 22:06:45+00:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/03_Graph/02_GraphAlgorithm/01.01.03.01_AOJ-GRL-1-A.test.cpp
documentation_of: 03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp
layout: document
redirect_from:
- /library/03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp
- /library/03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp.html
title: 03_Graph/02_GraphAlgorithm/01.01.03.01_single-source-shortest-path.weighted-graph.dijkstra.hpp
---
